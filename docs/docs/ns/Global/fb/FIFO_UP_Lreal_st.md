# QueueLib | [MAIN] | [NAMESPACES] | [METRICS] | [BACK]  

## Documentation for Function block FIFO_UP_Lreal  

```pascal
//Unordered Priority FIFO buffer. Allows Enqueing if buffer is not full. Dequeues the highest priority elements first.  
INTERFACE
    VAR_INPUT CONSTANT
        Buffer : POINTER TO dtFIFO_P_Element_LREAL := 0; (*Externally allocated buffer. Must be in format ARRAY[0..N]. ! Block doesn't check for Null pointer*)
        Size : UINT := 0; (*Size/Max elements of the buffer*)
    END_VAR
    VAR_OUTPUT 
        NrElements : UINT := 0; (*Number of elements in the FIFO*)
    END_VAR
    VAR 
        vLast : INT := -1; (*Position of the last item*)
    END_VAR
END_INTERFACE
FUNCTION_BLOCK FIFO_UP_Lreal:
    (***Developed entirely with methods***)
END_FUNCTION_BLOCK
METHOD Dequeue:
    INTERFACE
        VAR_OUTPUT 
            Value : LREAL; (*Return value*)
            Priority : INT; (*Return priority*)
        END_VAR
        VAR 
            vHighestPrioIdx : INT; (*Highest priority index*)
            i : INT; (*Iterator variable*)
        END_VAR
    END_INTERFACE
    IF isEmpty() THEN RETURN; END_IF

    //Get highest priority member
    vHighestPrioIdx := Peek();
    Value       := Buffer[vHighestPrioIdx].Value;
    Priority       := Buffer[vHighestPrioIdx].Priority;

    // reduce size of priority queue by first
    // shifting all elements one position left
    // from index where the highest priority item was found
    FOR i := vHighestPrioIdx TO vLast DO
        IF i >= vLast THEN
            EXIT;
        END_IF
        Buffer[i] := Buffer[i+1];
    END_FOR
    vLast := vLast - 1;

    NrElements  := NrElements - 1;

    Dequeue := TRUE;
    RETURN;
END_METHOD
METHOD Enqueue:
    INTERFACE
        VAR_INPUT 
            Value : LREAL; (*Value to add to queue*)
            Priority : INT; (*Return priority*)
        END_VAR
    END_INTERFACE
    IF isFull() THEN RETURN; END_IF

    vLast := vLast + 1;

    Buffer[vLast].Value         := Value;
    Buffer[vLast].Priority      := Priority;
    NrElements                  := NrElements + 1;

    Enqueue := TRUE;
    RETURN;
END_METHOD
METHOD isEmpty:
    INTERFACE
    END_INTERFACE
    isEmpty := vLast = -1;
    RETURN;
END_METHOD
METHOD isFull:
    INTERFACE
    END_INTERFACE
    isFull := vLast = Size - 1;
    RETURN;
END_METHOD
METHOD Peek:
    INTERFACE
        VAR_OUTPUT 
            Value : LREAL; (*Return value*)
            Priority : INT; (*Return priority*)
        END_VAR
        VAR 
            maxPrio : INT := -32768; (*Current highest priority value*)
            i : UINT; (*Iterator variable*)
        END_VAR
    END_INTERFACE
    IF isEmpty() THEN RETURN; END_IF

    // Linear search for highest priority
    FOR i:= 0 TO vLast DO
        // If two items have same priority choose the one with 
        // higher data value 
        IF maxPrio = Buffer[i].Priority AND Buffer[Peek].Value < Buffer[i].Value THEN
            maxPrio := Buffer[i].Priority;
            Peek := i;
            
        // note: using MAX Priority so higher priority number
        // means higher priority
        ELSIF maxPrio < Buffer[i].Priority THEN
            maxPrio := Buffer[i].Priority;
            Peek := i;
        END_IF
    END_FOR
    Value       := Buffer[Peek].Value;
    Priority    := Buffer[Peek].Priority;

    RETURN;
END_METHOD
```

## Metrics  

- VAR_INPUT : 2
- VAR_OUTPUT : 1
- VAR : 1

| Actions | Methods | Lines of code | Lines of comments | Lines in total | Maintainable size |
| ------- | ------- | ------------- | ----------------- | -------------- | ----------------- |
| 0 | 5 | 38 |10 |58 | 45 |

---
Autogenerated with [ia_tools](https://github.com/tkucic/ia_tools)  

[MAIN]: ../../../../index_st.md
[NAMESPACES]: ../../nsList_st.md
[METRICS]: ../../../metrics_st.md
[BACK]: ../nsMain_st.md
