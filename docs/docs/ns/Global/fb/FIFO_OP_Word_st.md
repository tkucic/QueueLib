# QueueLib | [MAIN] | [NAMESPACES] | [METRICS] | [BACK]  

## Documentation for Function block FIFO_OP_Word  

```pascal
//Ordered Priority FIFO buffer. Allows Enqueing if buffer is not full. Dequeues the highest priority elements first. Buffer is ordered from lowest to highest priority. e.g. 0 = Lowest priority  
INTERFACE
    VAR_INPUT CONSTANT
        Buffer : POINTER TO dtFIFO_P_Element_WORD := 0; (*Externally allocated buffer. Must be in format ARRAY[0..N]. ! Block doesn't check for Null pointer*)
        Size : UINT := 0; (*Size/Max elements of the buffer*)
    END_VAR
    VAR_OUTPUT 
        NrElements : UINT := 0; (*Number of elements in the FIFO*)
    END_VAR
END_INTERFACE
FUNCTION_BLOCK FIFO_OP_Word:
    (***Developed entirely with methods***)
END_FUNCTION_BLOCK
METHOD Dequeue:
    INTERFACE
        VAR_OUTPUT 
            Value : WORD; (*Return value*)
            Priority : INT; (*Return priority*)
        END_VAR
        VAR 
            vHighestIdx : INT; (*Highest priority index*)
        END_VAR
    END_INTERFACE
    IF isEmpty() THEN RETURN; END_IF

    //Get highest priority member
    Value       := Buffer[NrElements-1].Value;
    Priority    := Buffer[NrElements-1].Priority;

    NrElements  := NrElements - 1;

    Dequeue := TRUE;
    RETURN;
END_METHOD
METHOD Enqueue:
    INTERFACE
        VAR_INPUT 
            Value : WORD; (*Value to add to queue*)
            Priority : INT; (*Priority to add to queue*)
        END_VAR
        VAR 
            i : INT; (*Iterator variable*)
        END_VAR
    END_INTERFACE
    IF isFull() THEN RETURN; END_IF

    IF isEmpty() THEN
        Buffer[NrElements].Value         := Value;
        Buffer[NrElements].Priority      := Priority;
        NrElements                       := NrElements + 1;

        Enqueue := TRUE;
        RETURN;
    ELSE
        FOR i:= NrElements -1 TO 0 BY -1 DO
            // shift all items rightwards with higher priority
            // than the element we trying to insert
            IF Priority < Buffer[i].Priority THEN
                Buffer[i+1].Value       := Buffer[i].Value;
                Buffer[i+1].Priority    := Buffer[i].Priority;
            ELSE
                EXIT;
            END_IF
        END_FOR
        // insert item just before where
        // lower priority index was found
        Buffer[i+1].Value       := Value;
        Buffer[i+1].Priority    := Priority;
        NrElements              := NrElements + 1;
                
        Enqueue := TRUE;
        RETURN;
    END_IF



END_METHOD
METHOD isEmpty:
    INTERFACE
    END_INTERFACE
    isEmpty := NrElements = 0;
    RETURN;
END_METHOD
METHOD isFull:
    INTERFACE
    END_INTERFACE
    isFull := NrElements = Size;
    RETURN;
END_METHOD
METHOD Peek:
    INTERFACE
        VAR_OUTPUT 
            Value : WORD; (*Return value*)
            Priority : INT; (*Return priority*)
        END_VAR
    END_INTERFACE
    IF isEmpty() THEN RETURN; END_IF

    Peek        := NrElements-1;
    Value       := Buffer[Peek].Value;
    Priority    := Buffer[Peek].Priority;

    RETURN;
END_METHOD
```

## Metrics  

- VAR_INPUT : 2
- VAR_OUTPUT : 1

| Actions | Methods | Lines of code | Lines of comments | Lines in total | Maintainable size |
| ------- | ------- | ------------- | ----------------- | -------------- | ----------------- |
| 0 | 5 | 37 |6 |53 | 43 |

---
Autogenerated with [ia_tools](https://github.com/tkucic/ia_tools)  

[MAIN]: ../../../../index_st.md
[NAMESPACES]: ../../nsList_st.md
[METRICS]: ../../../metrics_st.md
[BACK]: ../nsMain_st.md
