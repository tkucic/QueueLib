# QueueLib | [MAIN] | [NAMESPACES] | [METRICS] | [BACK]  

## Documentation for Program LIFO_UnitTest  

```pascal
//Automated unit tests for function block LIFO  
INTERFACE
    VAR 
        vRunTests : BOOL := FALSE; (*Tap to TRUE, to run test*)
        vReturnsTrueOnSuccPushOk : BOOL := FALSE; (*Results*)
        vFillsThreeValuesOk : BOOL := FALSE;
        vReportsFullOk : BOOL := FALSE;
        vReturnsFalseOnUnSuccPushOk : BOOL := FALSE;
        vReturnsTrueOnSuccPopOk : BOOL := FALSE;
        vPop1Ok : BOOL := FALSE;
        vPop2Ok : BOOL := FALSE;
        vCountingWorks : BOOL := FALSE;
        vReportsEmptyOk : BOOL := FALSE;
        vReturnsTrueOnUnSuccPopOk : BOOL := FALSE;
        vPeekOk : BOOL := FALSE;
        v16bHandlingOk : BOOL := FALSE;
        lifo : LIFO_16b;
        vLifoBuffer : ARRAY[0..5] OF INT;
        vTempWord : WORD;
        vTempWordArr : ARRAY[0..3] OF WORD;
        vTempIdx : UINT;
    END_VAR
END_INTERFACE
PROGRAM LIFO_UnitTest:
    (*Init LIFO*)
    lifo.FB_Init(bInitRetains := TRUE, bInCopyCode := TRUE); //Implicit function block init, curtesy of codesys. To init function block on every run
    SysMemSet(ADR(vLifoBuffer), 0, SIZEOF(vLifoBuffer));
    lifo.Buffer := ADR(vLifoBuffer);
    lifo.Size   := SIZEOF(vLifoBuffer)/SIZEOF(INT);
    (***List of tests***)
    (***Test1: Lifo returns TRUE on successfull Push***)
    vReturnsTrueOnSuccPushOk := lifo.Push(1);

    (***Test2: Lifo fills three values correctly***)
    lifo.Push(2);
    lifo.Push(3);

    vFillsThreeValuesOk := vLifoBuffer[0] = 1 AND vLifoBuffer[1] = 2 AND vLifoBuffer[2] = 3;

    (***Test3: Lifo reports FULL when full***)
    lifo.Push(4);
    lifo.Push(5);
    lifo.Push(6);

    vReportsFullOk := lifo.isFull();

    (***Test4: Lifo reports FALSE on unsuccesfull Push***)
    vReturnsFalseOnUnSuccPushOk := NOT lifo.Push(7);

    (***Test5: Lifo returns TRUE on successfull Pop***)
    vReturnsTrueOnSuccPopOk := lifo.Pop(Value => vTempWord); //Returns 6

    (***Test6: Lifo dequeues values correctly***)
    lifo.Pop(Value => vTempWord);
    vPop1Ok := vTempWord = 5;
    lifo.Pop(Value => vTempWord);
    vPop2Ok := vTempWord = 4;

    (***Test7: Lifo can count correctly***)
    vCountingWorks := lifo.NrElements = 3; //At this point in the tests, there should be 3 elements

    (***Test8: Lifo reports EMPTY when EMPTY***)
    lifo.Pop(Value => vTempWord); //Returns 3
    lifo.Pop(Value => vTempWord); //Returns 2
    lifo.Pop(Value => vTempWord); //Returns 1
    vReportsEmptyOk := lifo.isEmpty();

    (***Test9: Lifo reports FALSE on unsuccesfull Pop***)
    vReturnsTrueOnUnSuccPopOk := NOT lifo.Pop();

    (***Test10: Peek functionality: Should return the next element but not remove it, it should report correct index of the buffer***)
    lifo.Push(1);
    lifo.Push(2);
    lifo.Push(3);
    vTempIdx := lifo.Peek(Value => vTempWord);
    vPeekOk := lifo.NrElements = 3 AND vTempWord = 3 AND vTempIdx = 2;

    (***Test11: 16bit handling: Multiple types should be returned***)
    WHILE NOT lifo.isEmpty() DO
        lifo.Pop();
    END_WHILE
    lifo.Push(INT#1);
    lifo.Push(INT#-1);
    lifo.Push(UINT#3);
    lifo.Push(WORD#4);

    lifo.Pop(Value => vTempWordArr[0]); //word 4
    lifo.Pop(Value => vTempWordArr[1]); //uint 3
    lifo.Pop(Value => vTempWordArr[2]); //int -1
    lifo.Pop(Value => vTempWordArr[3]); //int 1

    v16bHandlingOk := vTempWordArr[0] = 4
                  AND WORD_TO_UINT(vTempWordArr[1]) = 3
                  AND WORD_TO_INT(vTempWordArr[2]) = -1
                  AND WORD_TO_INT(vTempWordArr[3]) = 1;
                  
    vRunTests := FALSE;
END_PROGRAM
```

## Metrics  

- VAR : 18

| Actions | Methods | Lines of code | Lines of comments | Lines in total | Maintainable size |
| ------- | ------- | ------------- | ----------------- | -------------- | ----------------- |
| 0 | 0 | 45 |13 |73 | 63 |

---
Autogenerated with [ia_tools](https://github.com/tkucic/ia_tools)  

[MAIN]: ../../../../index_st.md
[NAMESPACES]: ../../nsList_st.md
[METRICS]: ../../../metrics_st.md
[BACK]: ../nsMain_st.md
